"""
Issue #3 Fix: Paper Trading Execution
Executes paper trades based on signals generated by signal_generation.py
Writes to paper_trades table
"""
from app.celery_app import celery_app
from app.db.database import SessionLocal
from app.db.models import User, Instrument, Model
from app.trading.decision_engine import DecisionEngine
from app.trading.paper_simulator import PaperSimulator
from sqlalchemy import text
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


@celery_app.task(bind=True)
def execute_paper_trades(self):
    """
    Execute paper trades based on signals
    
    Process:
    1. Get unexecuted signals
    2. For each signal, run through DecisionEngine
    3. If approved, create paper_trade entry
    4. Mark signal as executed
    """
    db = SessionLocal()
    decision_engine = DecisionEngine(db)  # ✅ FIXED: Pass db parameter
    simulator = PaperSimulator()
    
    try:
        # Get unexecuted BUY signals (recent, <5 min old)
        signals = db.execute(text("""
            SELECT s.id, s.model_id, s.instrument_id, s.signal_type, s.confidence,
                   i.symbol, m.name as model_name
            FROM signals s
            JOIN instruments i ON s.instrument_id = i.id
            JOIN models m ON s.model_id = m.id
            WHERE s.executed = false
            AND s.signal_type IN ('BUY', 'SELL')
            AND s.timestamp > NOW() - INTERVAL '5 minutes'
            ORDER BY s.timestamp DESC
        """)).fetchall()
        
        if not signals:
            logger.info("No unexecuted signals found")
            return {"status": "no_signals"}
        
        logger.info(f"Processing {len(signals)} unexecuted signals")
        trades_created = 0
        
        for signal in signals:
            signal_id = signal[0]
            model_id = signal[1]
            instrument_id = signal[2]
            signal_type = signal[3]
            confidence = signal[4]
            symbol = signal[5]
            
            try:
                # Get user who owns this model (via selected_model_ids)
                user = db.execute(text("""
                    SELECT id, email, paper_trading_enabled, auto_execute
                    FROM users
                    WHERE paper_trading_enabled = true
                    AND :model_id = ANY(selected_model_ids::uuid[])
                    LIMIT 1
                """), {"model_id": str(model_id)}).fetchone()
                
                if not user:
                    logger.debug(f"No user found for model {model_id}")
                    continue
                
                user_id = user[0]
                
                if not user[3]:  # auto_execute
                    logger.debug(f"Auto-execute disabled for user {user[1]}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # Get instrument
                instrument = db.query(Instrument).filter(Instrument.id == instrument_id).first()
                if not instrument:
                    continue
                
                # Get latest price from historical_candles
                latest_candle = db.execute(text("""
                    SELECT close FROM historical_candles
                    WHERE instrument_id = :instrument_id
                    ORDER BY ts_utc DESC
                    LIMIT 1
                """), {"instrument_id": str(instrument_id)}).fetchone()
                
                if not latest_candle:
                    logger.warning(f"No price data for {symbol}")
                    continue
                
                current_price = float(latest_candle[0])
                
                # Calculate position sizing (simplified for paper trading)
                from app.config import settings
                account_capital = settings.ACCOUNT_CAPITAL
                risk_per_trade = settings.RISK_PER_TRADE
                
                # Use ATR for stop/target (default values if not available)
                atr = current_price * 0.02  # 2% default ATR
                stop_price = current_price - (settings.STOP_MULTIPLIER * atr)
                target_price = current_price + (settings.TARGET_MULTIPLIER * atr)
                
                risk_per_share = current_price - stop_price
                risk_amount = account_capital * risk_per_trade
                qty = int(risk_amount / risk_per_share) if risk_per_share > 0 else 1
                
                if qty <= 0:
                    qty = 1  # Minimum 1 share
                
                # Simulate entry
                order_params = {
                    'symbol': symbol,
                    'entry_price': current_price,
                    'qty': qty,
                    'stop': stop_price,
                    'target': target_price
                }
                
                fill_result = simulator.simulate_entry(order_params)
                
                # Create paper trade
                db.execute(text("""
                    INSERT INTO paper_trades (
                        user_id, instrument_id, signal_id, action, quantity,
                        entry_price, stop_loss, target, status, entry_time
                    ) VALUES (
                        :user_id, :instrument_id, :signal_id, :action, :quantity,
                        :entry_price, :stop_loss, :target, 'ACTIVE', NOW()
                    )
                """), {
                    "user_id": str(user_id),
                    "instrument_id": str(instrument_id),
                    "signal_id": str(signal_id),
                    "action": signal_type,
                    "quantity": qty,
                    "entry_price": fill_result['filled_price'],
                    "stop_loss": stop_price,
                    "target": target_price
                })
                
                # Mark signal as executed
                db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                
                db.commit()
                trades_created += 1
                
                logger.info(f"✓ Created {signal_type} paper trade: {symbol} {qty}@{fill_result['filled_price']:.2f}")
                
            except Exception as e:
                logger.error(f"Error executing signal {signal_id}: {e}")
                db.rollback()
                continue
        
        logger.info(f"Paper trade execution complete: {trades_created} trades created")
        return {
            "status": "success",
            "trades_created": trades_created
        }
    
    except Exception as e:
        logger.error(f"Paper trade execution failed: {e}", exc_info=True)
        db.rollback()
        return {"status": "error", "error": str(e)}
    
    finally:
        db.close()


@celery_app.task(bind=True)
def monitor_paper_trades(self):
    """
    Monitor open paper trades and close them if stop/target is hit
    """
    db = SessionLocal()
    simulator = PaperSimulator()
    
    try:
        # Get active paper trades
        trades = db.execute(text("""
            SELECT pt.id, pt.instrument_id, pt.entry_price, pt.quantity,
                   pt.stop_loss, pt.target, i.symbol
            FROM paper_trades pt
            JOIN instruments i ON pt.instrument_id = i.id
            WHERE pt.status = 'ACTIVE'
        """)).fetchall()
        
        if not trades:
            return {"status": "no_trades"}
        
        closed_count = 0
        
        for trade in trades:
            trade_id = trade[0]
            instrument_id = trade[1]
            entry_price = trade[2]
            quantity = trade[3]
            stop_loss = trade[4]
            target = trade[5]
            symbol = trade[6]
            
            # Get latest price
            latest = db.execute(text("""
                SELECT close, high, low FROM historical_candles
                WHERE instrument_id = :instrument_id
                ORDER BY ts_utc DESC
                LIMIT 1
            """), {"instrument_id": str(instrument_id)}).fetchone()
            
            if not latest:
                continue
            
            current_tick = {
                'last_price': float(latest[0]),
                'high': float(latest[1]),
                'low': float(latest[2])
            }
            
            trade_params = {
                'entry_price': entry_price,
                'qty': quantity,  # ✅ FIXED: Use 'qty' not 'quantity' to match check_exit_conditions signature
                'stop': stop_loss,
                'target': target
            }
            
            # Check if stop/target hit
            exit_result = simulator.check_exit_conditions(current_tick, trade_params)
            
            if exit_result:
                # Close the trade
                db.execute(text("""
                    UPDATE paper_trades
                    SET status = :status, exit_price = :exit_price,
                        pnl = :pnl, exit_time = NOW()
                    WHERE id = :id
                """), {
                    "id": str(trade_id),
                    "status": exit_result['status'].upper(),
                    "exit_price": exit_result['exit_price'],
                    "pnl": exit_result['pnl']
                })
                db.commit()
                closed_count += 1
                
                logger.info(f"✓ Closed {symbol}: {exit_result['reason']} P&L={exit_result['pnl']:.2f}")
        
        return {"status": "success", "closed_count": closed_count}
    
    except Exception as e:
        logger.error(f"Trade monitoring failed: {e}", exc_info=True)
        db.rollback()
        return {"status": "error", "error": str(e)}
    
    finally:
        db.close()
