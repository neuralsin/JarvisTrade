"""
Issue #3 Fix: Paper Trading Execution
Executes paper trades based on signals generated by signal_generation.py
Writes to paper_trades table
"""
from app.celery_app import celery_app
from app.db.database import SessionLocal
from app.db.models import User, Instrument, Model
from app.trading.decision_engine import DecisionEngine
from app.trading.paper_simulator import PaperSimulator
from sqlalchemy import text
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


@celery_app.task(bind=True)
def execute_paper_trades(self):
    """
    Execute paper trades based on signals
    
    Process:
    1. Get unexecuted signals
    2. For each signal, run through DecisionEngine
    3. If approved, create paper_trade entry
    4. Mark signal as executed
    """
    db = SessionLocal()
    decision_engine = DecisionEngine(db)  # ✅ FIXED: Pass db parameter
    simulator = PaperSimulator()
    
    try:
        # Get unexecuted BUY signals (recent, <5 min old)
        signals = db.execute(text("""
            SELECT s.id, s.model_id, s.instrument_id, s.signal_type, s.confidence,
                   i.symbol, m.name as model_name
            FROM signals s
            JOIN instruments i ON s.instrument_id = i.id
            JOIN models m ON s.model_id = m.id
            WHERE s.executed = false
            AND s.signal_type IN ('BUY', 'SELL')
            AND s.timestamp > NOW() - INTERVAL '5 minutes'
            ORDER BY s.timestamp DESC
        """)).fetchall()
        
        if not signals:
            logger.info("No unexecuted signals found")
            return {"status": "no_signals"}
        
        logger.info(f"Processing {len(signals)} unexecuted signals")
        trades_created = 0
        
        for signal in signals:
            signal_id = signal[0]
            model_id = signal[1]
            instrument_id = signal[2]
            signal_type = signal[3]
            confidence = signal[4]
            symbol = signal[5]
            
            try:
                # Get user who owns this model (via selected_model_ids)
                user = db.execute(text("""
                    SELECT id, email, paper_trading_enabled, auto_execute
                    FROM users
                    WHERE paper_trading_enabled = true
                    AND :model_id = ANY(selected_model_ids::uuid[])
                    LIMIT 1
                """), {"model_id": str(model_id)}).fetchone()
                
                if not user:
                    logger.debug(f"No user found for model {model_id}")
                    continue
                
                user_id = user[0]
                
                if not user[3]:  # auto_execute
                    logger.debug(f"Auto-execute disabled for user {user[1]}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # =========================================================================
                # Bug fix: Decision Engine Bypass - Route through DecisionEngine validation
                # DecisionEngine enforces: kill switch, daily loss limits, trade count limits
                # =========================================================================
                
                # Check 1: Kill switch
                if decision_engine.check_kill_switch():
                    logger.warning(f"Kill switch active - skipping signal {signal_id}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # Check 2: Daily loss limit (with MTM)
                daily_loss_pct = decision_engine.check_daily_loss(str(user_id))
                from app.config import settings
                if daily_loss_pct >= settings.MAX_DAILY_LOSS:
                    logger.warning(f"Daily loss limit reached for user {user_id}: {daily_loss_pct:.2%}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # Check 3: Max trades per day
                trade_count = decision_engine.check_daily_trade_count(str(user_id))
                if trade_count >= settings.MAX_TRADES_PER_DAY:
                    logger.debug(f"Max trades per day reached for user {user_id}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # Check 4: Portfolio heat (via RiskManager)
                from app.trading.risk_manager import RiskManager
                risk_manager = RiskManager(db)
                heat_check = risk_manager.check_portfolio_heat(str(user_id))
                if not heat_check.get('safe', True):
                    logger.warning(f"Portfolio heat exceeded for user {user_id}: {heat_check.get('reason')}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # Check 5: Confidence threshold
                if confidence < settings.PROB_MIN:
                    logger.debug(f"Signal confidence {confidence:.2f} below threshold {settings.PROB_MIN}")
                    db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                    db.commit()
                    continue
                
                # Get instrument
                instrument = db.query(Instrument).filter(Instrument.id == instrument_id).first()
                if not instrument:
                    continue
                
                # Get latest price from historical_candles
                latest_candle = db.execute(text("""
                    SELECT close FROM historical_candles
                    WHERE instrument_id = :instrument_id
                    ORDER BY ts_utc DESC
                    LIMIT 1
                """), {"instrument_id": str(instrument_id)}).fetchone()
                
                if not latest_candle:
                    logger.warning(f"No price data for {symbol}")
                    continue
                
                current_price = float(latest_candle[0])
                
                # Calculate position sizing (simplified for paper trading)
                from app.config import settings
                account_capital = settings.ACCOUNT_CAPITAL
                risk_per_trade = settings.RISK_PER_TRADE
                
                # Bug fix #3: Fetch stop/target from Signal table instead of hardcoded 2% ATR
                signal_record = db.execute(text("""
                    SELECT stop_loss, take_profit FROM signals WHERE id = :id
                """), {"id": str(signal_id)}).fetchone()
                
                if signal_record and signal_record[0] and signal_record[1]:
                    stop_price = float(signal_record[0])
                    target_price = float(signal_record[1])
                else:
                    # Fallback with volatility floor (Bug fix #4)
                    atr = current_price * max(0.02, settings.MIN_ATR_FLOOR_PCT)
                    stop_price = current_price - (settings.STOP_MULTIPLIER * atr)
                    target_price = current_price + (settings.TARGET_MULTIPLIER * atr)
                
                # Bug fix #4: Volatility floor to prevent divide-by-zero
                risk_per_share = current_price - stop_price
                min_risk = current_price * settings.MIN_ATR_FLOOR_PCT
                risk_per_share = max(risk_per_share, min_risk)
                
                risk_amount = account_capital * risk_per_trade
                qty = int(risk_amount / risk_per_share) if risk_per_share > 0 else 1
                
                # Bug fix #4: Position size cap (share count - legacy)
                qty = min(qty, settings.MAX_POSITION_SIZE)
                
                # CRITICAL FIX: Value-based position cap (prevents massive exposure on high-value stocks)
                # e.g., ₹20,000 stock * 500 shares = ₹1 Crore exposure - DANGEROUS
                max_qty_by_value = int(settings.MAX_POSITION_VALUE / current_price) if current_price > 0 else 1
                qty = min(qty, max_qty_by_value)
                
                if qty <= 0:
                    qty = 1  # Minimum 1 share
                
                # Simulate entry
                order_params = {
                    'symbol': symbol,
                    'entry_price': current_price,
                    'qty': qty,
                    'stop': stop_price,
                    'target': target_price
                }
                
                fill_result = simulator.simulate_entry(order_params)
                
                # Create paper trade
                db.execute(text("""
                    INSERT INTO paper_trades (
                        user_id, instrument_id, signal_id, action, quantity,
                        entry_price, stop_loss, target, status, entry_time
                    ) VALUES (
                        :user_id, :instrument_id, :signal_id, :action, :quantity,
                        :entry_price, :stop_loss, :target, 'ACTIVE', NOW()
                    )
                """), {
                    "user_id": str(user_id),
                    "instrument_id": str(instrument_id),
                    "signal_id": str(signal_id),
                    "action": signal_type,
                    "quantity": qty,
                    "entry_price": fill_result['filled_price'],
                    "stop_loss": stop_price,
                    "target": target_price
                })
                
                # Mark signal as executed
                db.execute(text("UPDATE signals SET executed = true WHERE id = :id"), {"id": str(signal_id)})
                
                db.commit()
                trades_created += 1
                
                logger.info(f"✓ Created {signal_type} paper trade: {symbol} {qty}@{fill_result['filled_price']:.2f}")
                
            except Exception as e:
                logger.error(f"Error executing signal {signal_id}: {e}")
                db.rollback()
                continue
        
        logger.info(f"Paper trade execution complete: {trades_created} trades created")
        return {
            "status": "success",
            "trades_created": trades_created
        }
    
    except Exception as e:
        logger.error(f"Paper trade execution failed: {e}", exc_info=True)
        db.rollback()
        return {"status": "error", "error": str(e)}
    
    finally:
        db.close()


@celery_app.task(bind=True)
def monitor_paper_trades(self):
    """
    Monitor open paper trades and close them if stop/target is hit
    """
    db = SessionLocal()
    simulator = PaperSimulator()
    
    try:
        # Get active paper trades
        trades = db.execute(text("""
            SELECT pt.id, pt.instrument_id, pt.entry_price, pt.quantity,
                   pt.stop_loss, pt.target, i.symbol
            FROM paper_trades pt
            JOIN instruments i ON pt.instrument_id = i.id
            WHERE pt.status = 'ACTIVE'
        """)).fetchall()
        
        if not trades:
            return {"status": "no_trades"}
        
        closed_count = 0
        
        for trade in trades:
            trade_id = trade[0]
            instrument_id = trade[1]
            entry_price = trade[2]
            quantity = trade[3]
            stop_loss = trade[4]
            target = trade[5]
            symbol = trade[6]
            
            # Get latest price
            latest = db.execute(text("""
                SELECT close, high, low FROM historical_candles
                WHERE instrument_id = :instrument_id
                ORDER BY ts_utc DESC
                LIMIT 1
            """), {"instrument_id": str(instrument_id)}).fetchone()
            
            if not latest:
                continue
            
            current_tick = {
                'last_price': float(latest[0]),
                'high': float(latest[1]),
                'low': float(latest[2])
            }
            
            trade_params = {
                'entry_price': entry_price,
                'qty': quantity,  # ✅ FIXED: Use 'qty' not 'quantity' to match check_exit_conditions signature
                'stop': stop_loss,
                'target': target
            }
            
            # Check if stop/target hit
            exit_result = simulator.check_exit_conditions(current_tick, trade_params)
            
            if exit_result:
                # Close the trade
                db.execute(text("""
                    UPDATE paper_trades
                    SET status = :status, exit_price = :exit_price,
                        pnl = :pnl, exit_time = NOW()
                    WHERE id = :id
                """), {
                    "id": str(trade_id),
                    "status": exit_result['status'].upper(),
                    "exit_price": exit_result['exit_price'],
                    "pnl": exit_result['pnl']
                })
                db.commit()
                closed_count += 1
                
                logger.info(f"✓ Closed {symbol}: {exit_result['reason']} P&L={exit_result['pnl']:.2f}")
        
        return {"status": "success", "closed_count": closed_count}
    
    except Exception as e:
        logger.error(f"Trade monitoring failed: {e}", exc_info=True)
        db.rollback()
        return {"status": "error", "error": str(e)}
    
    finally:
        db.close()
